# 字节码指令集与解析举例

## 概述

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。

由于限制了Java虚拟机的长度为一个字节（0~255），意味着指令集的操作码总数不可能超过256条。

### 执行模型

如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面伪代码当做最基本的执行模型来理解。

```java
do{
    自动计算PC寄存器的值加1;
    根据PC寄存器的指示位置，从字节码流中取出操作码;
    if(字节码存在操作数)从字节码流中取出操作数;
    执行操作码所定义的操作;
}while(字节码长度>0);
```

### 字节码与数据类型

在Java虚拟机的指令集中，大多数指令都包含了其所操作所对应的数据类型信息。比如：iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的是float类型的数据。

对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来标明专门为哪种数据类型服务：

- i代表对int类型的数据操作
- l代表long
- s代表short
- b代表byte
- c代表char
- f代表float
- d代表double

也有一些指令的助记符中没有明确地指令操作类型的字母，如arraylength指令，他没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。

还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。

大部分的指令都没有支持整数类型byte、char和short，身子没有任何指令支持boolean类型。编译器会在编译器或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用相应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。

### 指令分类

- 加载与存储指令
- 算数指令
- 类型转换指令
- 对象的创建与访问指令
- 方法调用与返回指令
- 操作数栈管理指令
- 比较控制指令
- 异常处理指令
- 同步控制指令

## 加载与存储指令

### 作用

加载和存储指令用于将数据从栈桢的局部变量表和操作数栈之间来回传递。

### 常用指令

1. 局部变量压栈指令：将一个局部变量加载到操作数栈：xload、xload_<n> （其中x为i、l、f、d、a，n为0~3）
2. 常量入栈指令：将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d>
3. 出栈装入局部变量表指令：将一个数值从操作数栈存储到局部变量表：xstore、xstore_<n>（其中x为i、l、f、d、a，n为0~3）；xastore（其中x为i、l、f、d、a、b、c、s）
4. 扩充局部变量表的访问索引的指令：wide。

上面列举的指令助记符中，有一部分是以尖括号结尾的。这些指令助记符实际上代表了一组指令（iload_<n>代表了iload_0、iload_1、iload_2、iload_3这几个指令）。这几组指令都是某个带有一个操作数的通用指令的特殊形式，对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。

操作byte、char、short、boolean类型数据时，进场用int类型的指令来表示。

### 局部变量压栈指令

局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。

这类指令大体可以分为：

- xload_<n>（x为i、l、f、d、a，n为0~3）
- xload（x为i、l、f、d、a）

指令xload_n表示将第n个局部变量压入操作数栈，比如iload_1、fload_0、aload_0等指令。其中aload_n表示将一个对象引用压栈。

指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如iload、fload等。

```java
// 局部变量压入栈指令
public void load(int num, Object obj, long count, boolean flag,short[] arr){
    System.out.println(num);
    System.out.println(obj);
    System.out.println(count);
    System.out.println(flag);
    System.out.println(arr);
}
```

![load字节码执行](https://github.com/jackhusky/jvm/blob/main/docs/images/load字节码执行.png)

### 常量入栈指令

常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为const系列、push系列、push系列和ldc指令。

指令const系列：用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：iconst_<i>（i从-1到5）、lconst_<l>（l从0~1）、fconst_<f>（f从0~2）、dconst_<d>（d从0~1）、aconst_null。

指令push系列：主要包含bipush和sipush。他们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈。

指令ldc系列：如果以上指令都不能满足需求，那么可以使用万能的ldc指令，它可以接收一个8位的参数，该参数指向常量池中的int、float或者String的索引，将指定的内容压入堆栈。

类似的还有ldc_w，它接收两个8位参数，能支持的索引范围大于ldc。

如果要压入的元素是long或者double类型的，则使用ldc2_w指令。

总结：

| 类型                         | 常数指令 | 范围                         |
| ---------------------------- | -------- | ---------------------------- |
| int(boolean,byte,char,short) | iconst   | [-1,5)                       |
|                              | bipush   | [-128,127]                   |
|                              | sipush   | [-32768,32767]               |
|                              | ldc      | any int value                |
| long                         | lconst   | 0,1                          |
|                              | ldc      | any long value               |
| float                        | fconst   | 0,1,2                        |
|                              | ldc      | any float value              |
| double                       | dconst   | 0,1                          |
|                              | ldc      | any double value             |
| reference                    | aconst   | null                         |
|                              | ldc      | String literal,Class literal |

代码：

```java
// 常量入栈指令
public void pushConstLdc(){
    int i = -1;
    int a = 5;
    int b = 6;
    int c = 127;
    int d = 128;
    int e = 32767;
    int f = 32768;
}
```

字节码：

```java
 0 iconst_m1
 1 istore_1
 2 iconst_5
 3 istore_2
 4 bipush 6
 6 istore_3
 7 bipush 127
 9 istore 4
11 sipush 128
14 istore 5
16 sipush 32767
19 istore 6
21 ldc #7 <32768>
23 istore 7
25 return
```

代码：

```java
public void constLdc(){
    long a1 = 1;
    long a2 = 2;
    float b1 = 2;
    float b2 = 3;
    double c1 = 1;
    double c2 = 2;
    Date d = null;
}
```

字节码：

```java
 0 lconst_1
 1 lstore_1
 2 ldc2_w #8 <2>
 5 lstore_3
 6 fconst_2
 7 fstore 5
 9 ldc #10 <3.0>
11 fstore 6
13 dconst_1
14 dstore 7
16 ldc2_w #11 <2.0>
19 dstore 9
21 aconst_null
22 astore 11
24 return
```

### 出栈装入局部变量表指令

出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量表赋值。

这类指令主要以store的形式存在，比如xstore（x为i、l、f、d、a）、xstore_n（x为i、l、f、d、a，n为0~3）。

- 其中，指令istore_n将从操作数栈中弹出一个整数，并把它赋值给局部变量表索引n位置。
- 指令xstore由于没有隐含参数信息，故需要提供一个byte类型的参数类指定目标局部变量表的位置。

```java
public void store(int k, double d){
    int m = k + 2;
    long l = 12;
    String str = "abcdef";
    float f = 10.0F;
    d = 10;
}
```

字节码：

```java
 0 iload_1
 1 iconst_2
 2 iadd
 3 istore 4
 5 ldc2_w #13 <12>
 8 lstore 5
10 ldc #15 <abcdef>
12 astore 7
14 ldc #16 <10.0>
16 fstore 8
18 ldc2_w #17 <10.0>
21 dstore_2
22 return
```

说明：

一般来说，类似像store这样的指令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是为了尽可能压缩指令大小，使用专门的istore_1指令表示将弹出的元素放在局部变量表第1个位置。类似还有istore_0、istore_2、istore_3。

由于局部变量表前几个位置总是非常有用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。

## 算数指令

### 作用

算数指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。

### 分类

大体上分为两种：对整型数据进行运算的指令和浮点型数据进行运算的指令。

### byte、short、char和boolean类型说明

| 实际类型      | 运算类型      | 分类 |
| ------------- | ------------- | ---- |
| boolean       | int           | 一   |
| byte          | int           | 一   |
| char          | int           | 一   |
| short         | int           | 一   |
| int           | int           | 一   |
| float         | float         | 一   |
| reference     | reference     | 一   |
| returnAddress | returnAddress | 一   |
| long          | long          | 二   |
| double        | double        | 二   |

### NaN值使用

当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。

### 所有算术指令

加法指令：iadd、ladd、fadd、dadd

减法指令：isub、lsub、fsub、dsub

乘法指令：imul、lmul、fmul、dmul

除法指令：idiv、ldiv、fdiv、ddiv

求余指令：irem、lrem、frem、drem       //remainder：余数

取反指令：ineg、lneg、fneg、dneg      //negation：取反

自增指令：iinc

位运算指令：

- 位移指令：ishl、ishr、iushr、lshl、lshr、lushr
- 按位或指令：ior、lor
- 按位与指令：iand、land
- 按位异或指令：ixor、lxor

比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp

### 比较指令的说明

- 比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。
- 首字符d表示double类型，f表示float，l表示long。
- 对于double和float类型的数字，由于NaN的存在，各有两个版本的指令。
- 由于long型整数没有NaN值，所以没有两套指令。
- 两个指令不同在于，如果遇到NaN值，fcmpg会压入1，而fcmpl会压入-1。

## 类型转换指令

1. 类型转换指令可以将两种不同的数值类型进行相互转换。
2. 这些转换操作作用用于实现用户代码中的显示类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。

### 宽化类型转换

1. 转换规则：Java虚拟机直接支持以下数值的宽化类型转换（小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行。

   - 从int类型到long、float或者double类型。对应的指令是：i2l、i2f、i2d
   - 从long类型到float、double类型。对应的指令是：l2f、l2d
   - 从float类型到double类型。对应的指令是：f2d

   int --> long --> float --> double

2. 精度损失问题

   - 宽化类型转换是不会因为超过目标类型最大值而丢失信息的。
   - 从int、long类型数值转换为float，或者long类型转换到double时，可能发生精度丢失。

3. 补充说明

   从byte、char、short类型到int类型的宽化类型转换实际是不存在的。虚拟机的目前设计上，只使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将short和byte当做int处理也在情理之中。

   另一方面，由于局部变量表中的槽位固定是32位，无论是byte或者short存入局部变量表，都会占用32位空间，从这个角度来看，也没有必要特意区分这几种数据类型。

### 窄化类型转换

1. 转换规则

   - 从int类型到byte、short、char类型。对应指令有：i2b、i2s、i2c
   - 从long类型到int类型。对应指令有：l2i
   - 从float类型到int或者long类型。对应指令有：f2i、f2l
   - 从double类型到int、long、float类型。对应指令有：d2i、d2l、d2f

2. 精度损失问题

   窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。

## 对象的创建与访问指令



## 方法调用与返回指令



## 操作数栈管理指令



## 比较控制指令



## 异常处理指令



## 同步控制指令

