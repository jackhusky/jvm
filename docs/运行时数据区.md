# 运行时数据区

![运行时数据区](https://github.com/jackhusky/jvm/blob/main/docs/images/运行时数据区.png)

- 每个线程：程序计数器、栈、本地栈。
- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）。

## 程序计数器（PC寄存器）

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

![PC寄存器](https://github.com/jackhusky/jvm/blob/main/docs/images/PC寄存器.png)

## 虚拟机栈

 Java的指令都是根据栈来设计的，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

栈是运行时的单位，而堆是存储的单位。栈主管Java程序的运行，保存了方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。

- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建时独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出`java.lang.StackOverflowError`异常。
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出OOM异常。

```java
// java.lang.StackOverflowError
public class Main {
    public static void main(String[] args) {
        main(args);
    }
}
```

> -Xss256k：设置栈的大小

### 栈的存储单位

![栈运行原理](https://github.com/jackhusky/jvm/blob/main/docs/images/栈运行原理.png)

- 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。
- 在这个线程上正在执行的每个方法都各自对应一个栈帧。
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

### 栈的运行原理

- JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”（FILO）原则。
- 在一条活动线程中，一个时间点上，只有一个活动的栈帧。只有当前正在执行的方法的栈帧是有效的，这个栈帧被称为当前栈帧，与当前栈帧对应的方法就是当前方法，定义这个方法的类就是当前类。
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放子栈的顶端，称为新的当前帧。
- 不同线程中所包含的栈帧是不允许存在相互引用的， 即不可能在一个栈帧中引用另外一个线程的栈帧。
- 如果当前方法调用了其他方法 ，方法返回之际，当前栈帧会传回此方法的之心结果给前一个帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
- Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。

### 栈帧的内部结构

- **局部变量表（Local Variables）**
- **操作数栈（Operand Stack）**
- 动态链接（Dynamic Linking）（指向运行时常量池的方法定义）
- 方法返回地址（Return Address）（方法正常退出或者异常退出的定义）
- 一些附加信息

### 局部变量表

- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference）、以及returnAddress类型。
- 建立在线程的栈上，是线程的私有数据，不存在数据安全问题。
- 所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables中。

#### 关于slot的理解

- 局部变量表最基本的存储单位是slot（变量槽）
- 32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot
  - byte、short、char在存储前被转为int，boolean也被转为int，0表示flase，非0表示true。
  - long和double占据两个slot。

- 当一个实例方法被调用的时候，他的方法参数和方法内部定义的局部变量会按照顺序复制到局部变量表的slot上。
- 如果访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。
- 如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处。

```java
public void method1(){
        int a = 1;
        double b = 2.0;
        String str = "string";
    }
```

局部变量表

![局部变量表demo](https://github.com/jackhusky/jvm/blob/main/docs/images/局部变量表demo.png)

#### slot的重复利用

```java
public void method2(){
        int a = 10;
        {
            int b = 0;
            b++;
        }
        // 变量c使用之前已经销毁的变量b占用的slot
        int c = 20;
    }
```

![局部变量表demo2](https://github.com/jackhusky/jvm/blob/main/docs/images/局部变量表demo2.png)

### 操作数栈

每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈。在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈。

- 主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间。
- 每个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的Code属性中为max_stack的值。
- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。

```java
public void test() {
        byte i = 15;
        int j = 8;
        int k = i + j;
    }
```

![操作数栈代码追踪1](https://github.com/jackhusky/jvm/blob/main/docs/images/操作数栈代码追踪1.png)

### 动态链接

- 每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。

- Java源文件编译为字节码文件时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。描述一个方法调用另外的方法时，就是通过常量池中指向方法的符号引用来表示的，动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

![动态链接](https://github.com/jackhusky/jvm/blob/main/docs/images/动态链接.png)

### 方法的调用

####  静态链接和动态链接

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

- 静态链接：当一个字节码被装载进JVM内部时，如果被调用的**目标方法在编译器可知**，且运行期保持不变。这种情况下将调用方法的符号引用转换为直接引用的过车行称之为静态链接。

- 动态链接：被调用的方法在编译期间无法被确定下来，只能在程序运行期将调用方法的符号引用
  转换为直接引用，由于这种引用转换过程具备动态性，因此被称为动态链接。

#### 早期绑定和晚期绑定

对应的方法的绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或类在符号引用被替换为直接引用的过程，这仅仅发生一次。

#### 虚方法和非虚方法

- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。称为非虚方法。
- 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
- 其他方法称为虚方法。

虚拟机中提供了以下几条方法调用指令：

- 普通调用指令：

  1、invokestatic：调用静态方法，解析阶段确定唯一方法版本。

  2、invokespecial：调用`<init>`方法、私有及父类方法，解析阶段确定唯一方法版本。

  3、invokevirtual：调用所有虚方法。

  4、invokeinterface：调用接口方法。

- 动态调用指令：

  5、invokedynamic：动态解析出需要调用的方法，然后执行。（Lambda表达式）

invokestatic指令和invokespecial指令调用的方法非虚方法，其余的（final修饰的除外）称为虚方法。

#### 虚方法表

如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。为了提高性能，JVM采用在类的方法区建立一个**虚方法表（非虚方法不会出现在表中）来实现。使用索引表来代替查找。**

虚方法表会在类加载的链接阶段被创建并开始初始化（解析阶段）

![虚方法表](https://github.com/jackhusky/jvm/blob/main/docs/images/虚方法表.png)

### 方法返回地址

- 存放调用该方法的PC寄存器的值。
- 正常退出，调用者的PC寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址。异常退出，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。 

### 附加信息

## 本地方法栈

- Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。

- 线程私有的。
- 允许被是线程固定或者可动态扩展的内存大小。
- 本地方法是使用C语言实现的。
- Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。
- 当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限。
  - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。
  - 它甚至可以直接使用本地处理器中的寄存器。
  - 直接从本地内存的堆中分配任意数量的内存。

- 并不是所有的JVM都支持本地方法。因为Java虚拟机规范没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。
- 在HotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一。