# 运行时数据区

![运行时数据区](https://github.com/jackhusky/jvm/blob/main/docs/images/运行时数据区.png)

- 每个线程：程序计数器、栈、本地栈。
- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）。

## 程序计数器（PC寄存器）

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

![PC寄存器](https://github.com/jackhusky/jvm/blob/main/docs/images/PC寄存器.png)

## 虚拟机栈

 Java的指令都是根据栈来设计的，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

栈是运行时的单位，而堆是存储的单位。栈主管Java程序的运行，保存了方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。

- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建时独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出`java.lang.StackOverflowError`异常。
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出OOM异常。

```java
// java.lang.StackOverflowError
public class Main {
    public static void main(String[] args) {
        main(args);
    }
}
```

> -Xss256k：设置栈的大小

### 栈的存储单位

![栈运行原理](https://github.com/jackhusky/jvm/blob/main/docs/images/栈运行原理.png)

- 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。
- 在这个线程上正在执行的每个方法都各自对应一个栈帧。
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

### 栈的运行原理

- JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”（FILO）原则。
- 在一条活动线程中，一个时间点上，只有一个活动的栈帧。只有当前正在执行的方法的栈帧是有效的，这个栈帧被称为当前栈帧，与当前栈帧对应的方法就是当前方法，定义这个方法的类就是当前类。
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放子栈的顶端，称为新的当前帧。
- 不同线程中所包含的栈帧是不允许存在相互引用的， 即不可能在一个栈帧中引用另外一个线程的栈帧。
- 如果当前方法调用了其他方法 ，方法返回之际，当前栈帧会传回此方法的之心结果给前一个帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
- Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。

### 栈帧的内部结构

- **局部变量表（Local Variables）**
- **操作数栈（Operand Stack）**
- 动态链接（Dynamic Linking）（指向运行时常量池的方法定义）
- 方法返回地址（Return Address）（方法正常退出或者异常退出的定义）
- 一些附加信息

### 局部变量表

- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference）、以及returnAddress类型。
- 建立在线程的栈上，是线程的私有数据，不存在数据安全问题。
- 所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables中。

#### 关于slot的理解

- 局部变量表最基本的存储单位是slot（变量槽）
- 32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot
  - byte、short、char在存储前被转为int，boolean也被转为int，0表示flase，非0表示true。
  - long和double占据两个slot。

- 当一个实例方法被调用的时候，他的方法参数和方法内部定义的局部变量会按照顺序复制到局部变量表的slot上。
- 如果访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。
- 如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处。

```java
public void method1(){
        int a = 1;
        double b = 2.0;
        String str = "string";
    }
```

局部变量表

![局部变量表demo](https://github.com/jackhusky/jvm/blob/main/docs/images/局部变量表demo.png)

#### slot的重复利用

```java
public void method2(){
        int a = 10;
        {
            int b = 0;
            b++;
        }
        // 变量c使用之前已经销毁的变量b占用的slot
        int c = 20;
    }
```

![局部变量表demo2](https://github.com/jackhusky/jvm/blob/main/docs/images/局部变量表demo2.png)

### 操作数栈

每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈。在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈。

- 主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间。
- 每个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的Code属性中为max_stack的值。
- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。

```java
public void test() {
        byte i = 15;
        int j = 8;
        int k = i + j;
    }
```

![操作数栈代码追踪1](https://github.com/jackhusky/jvm/blob/main/docs/images/操作数栈代码追踪1.png)

### 动态链接

- 每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。

- Java源文件编译为字节码文件时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。描述一个方法调用另外的方法时，就是通过常量池中指向方法的符号引用来表示的，动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

![动态链接](https://github.com/jackhusky/jvm/blob/main/docs/images/动态链接.png)

### 方法的调用

####  静态链接和动态链接

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

- 静态链接：当一个字节码被装载进JVM内部时，如果被调用的**目标方法在编译器可知**，且运行期保持不变。这种情况下将调用方法的符号引用转换为直接引用的过车行称之为静态链接。

- 动态链接：被调用的方法在编译期间无法被确定下来，只能在程序运行期将调用方法的符号引用
  转换为直接引用，由于这种引用转换过程具备动态性，因此被称为动态链接。

#### 早期绑定和晚期绑定

对应的方法的绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或类在符号引用被替换为直接引用的过程，这仅仅发生一次。

#### 虚方法和非虚方法

- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。称为非虚方法。
- 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
- 其他方法称为虚方法。

虚拟机中提供了以下几条方法调用指令：

- 普通调用指令：

  1、invokestatic：调用静态方法，解析阶段确定唯一方法版本。

  2、invokespecial：调用`<init>`方法、私有及父类方法，解析阶段确定唯一方法版本。

  3、invokevirtual：调用所有虚方法。

  4、invokeinterface：调用接口方法。

- 动态调用指令：

  5、invokedynamic：动态解析出需要调用的方法，然后执行。（Lambda表达式）

invokestatic指令和invokespecial指令调用的方法非虚方法，其余的（final修饰的除外）称为虚方法。

#### 虚方法表

如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。为了提高性能，JVM采用在类的方法区建立一个**虚方法表（非虚方法不会出现在表中）来实现。使用索引表来代替查找。**

虚方法表会在类加载的链接阶段被创建并开始初始化（解析阶段）

![虚方法表](https://github.com/jackhusky/jvm/blob/main/docs/images/虚方法表.png)

### 方法返回地址

- 存放调用该方法的PC寄存器的值。
- 正常退出，调用者的PC寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址。异常退出，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。 

### 附加信息

## 本地方法栈

- Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。

- 线程私有的。
- 允许被是线程固定或者可动态扩展的内存大小。
- 本地方法是使用C语言实现的。
- Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。
- 当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限。
  - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。
  - 它甚至可以直接使用本地处理器中的寄存器。
  - 直接从本地内存的堆中分配任意数量的内存。

- 并不是所有的JVM都支持本地方法。因为Java虚拟机规范没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。
- 在HotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一。

## 堆

![java堆](https://github.com/jackhusky/jvm/blob/main/docs/images/java堆.png)

- 一个JVM实例只存在一个堆内存，也是Java内存管理的核心区域。
- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。
  - 堆内存的大小是可以调节的。
- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。

- 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。
  - 从实际使用角度看，几乎所有的对象实例都在堆上分配内存。
- 数组和对线可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
- 堆是GC执行垃圾回收的重点区域。

### 内存细分

- Java7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区
- Java8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间

### 堆空间大小的设置

- `-Xms`用来表示堆区（年轻代+老年代）的起始内存，等价于`-XX:InitialHeapSize`。
- `-Xmx`用来表示堆区的最大内存，等价于`-XX:MaxHeapSize`。
- 通常会将`-Xms`和`-Xmx`两个参数配置相同的值，目的是**为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。**

- 默认情况下，初始内存大小是电脑内存大小的1/64，最大内存大小是电脑内存大小的1/4。

### 年轻代和老年代

![年轻代和老年代](https://github.com/jackhusky/jvm/blob/main/docs/images/年轻代和老年代.png)

- 配置新生代与老年代在堆结构的占比，一般不会修改

  - 默认`-XX:NewRatio`=2，表示新生代占1，老年代占2，新生代占整个堆的1/3。

- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1。
- 当然开发人员可通过`-XX:SurvivorRatio=8`调整这个空间比例。（需要显示设置）
  - `-XX:-UseAdaptiveSizePolicy`：关闭自适应的内存分配策略
- 几乎所有的Java对象都是在Eden区内new出来的。
- 绝大部分的Java对象的销毁都在新生代进行了。
- 可以使用选项`-Xmn`新生代的空间大小。 （一般不设置）

### 对象分配过程

![对象分配过程](https://github.com/jackhusky/jvm/blob/main/docs/images/对象分配过程.png)

- 可以设置去养老区需要复制的次数，默认为15次。
  - `-XX:MaxTenuringThreshold=<N>`进行设置。

- 针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to。
- 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区/元空间收集。

**特殊情况**

![对象分配过程特殊情况](https://github.com/jackhusky/jvm/blob/main/docs/images/对象分配过程特殊情况.png)

























