# 运行时数据区

![运行时数据区](https://github.com/jackhusky/jvm/blob/main/docs/images/运行时数据区.png)

- 每个线程：程序计数器、栈、本地栈。
- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）。

## 程序计数器（PC寄存器）

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

![PC寄存器](https://github.com/jackhusky/jvm/blob/main/docs/images/PC寄存器.png)

## 虚拟机栈

 Java的指令都是根据栈来设计的，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

栈是运行时的单位，而堆是存储的单位。栈主管Java程序的运行，保存了方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。

- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建时独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出`java.lang.StackOverflowError`异常。
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出OOM异常。

```java
// java.lang.StackOverflowError
public class Main {
    public static void main(String[] args) {
        main(args);
    }
}
```

> -Xss256k：设置栈的大小

### 栈的存储单位

![栈运行原理](https://github.com/jackhusky/jvm/blob/main/docs/images/栈运行原理.png)

- 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。
- 在这个线程上正在执行的每个方法都各自对应一个栈帧。
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

### 栈的运行原理

- JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”（FILO）原则。
- 在一条活动线程中，一个时间点上，只有一个活动的栈帧。只有当前正在执行的方法的栈帧是有效的，这个栈帧被称为当前栈帧，与当前栈帧对应的方法就是当前方法，定义这个方法的类就是当前类。
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放子栈的顶端，称为新的当前帧。
- 不同线程中所包含的栈帧是不允许存在相互引用的， 即不可能在一个栈帧中引用另外一个线程的栈帧。
- 如果当前方法调用了其他方法 ，方法返回之际，当前栈帧会传回此方法的之心结果给前一个帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
- Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。

### 栈帧的内部结构

- **局部变量表（Local Variables）**
- **操作数栈（Operand Stack）**
- 动态链接（Dynamic Linking）（指向运行时常量池的方法定义）
- 方法返回地址（Return Address）（方法正常退出或者异常退出的定义）
- 一些附加信息

### 局部变量表

- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference）、以及returnAddress类型。
- 建立在线程的栈上，是线程的私有数据，不存在数据安全问题。
- 所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables中。

#### 关于slot的理解

- 局部变量表最基本的存储单位是slot（变量槽）
- 32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot
  - byte、short、char在存储前被转为int，boolean也被转为int，0表示flase，非0表示true。
  - long和double占据两个slot。

- 当一个实例方法被调用的时候，他的方法参数和方法内部定义的局部变量会按照顺序复制到局部变量表的slot上。
- 如果访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。
- 如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处。

```java
public void method1(){
        int a = 1;
        double b = 2.0;
        String str = "string";
    }
```

局部变量表

![局部变量表demo](https://github.com/jackhusky/jvm/blob/main/docs/images/局部变量表demo.png)

#### slot的重复利用

```java
public void method2(){
        int a = 10;
        {
            int b = 0;
            b++;
        }
        // 变量c使用之前已经销毁的变量b占用的slot
        int c = 20;
    }
```

![局部变量表demo2](https://github.com/jackhusky/jvm/blob/main/docs/images/局部变量表demo2.png)

### 操作数栈

每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈。在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈。

- 主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间。
- 每个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的Code属性中为max_stack的值。
- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。

```java
public void test() {
        byte i = 15;
        int j = 8;
        int k = i + j;
    }
```

![操作数栈代码追踪1](https://github.com/jackhusky/jvm/blob/main/docs/images/操作数栈代码追踪1.png)

