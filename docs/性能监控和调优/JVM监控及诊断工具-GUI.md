# JVM监控及诊断工具-GUI

## 工具概述

- JDK自带的工具
  - jconsole：JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息、永久代（或元空间）使用情况、类加载情况等
  - Visual VM：提供了可是界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。
  - JMC：Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据。
- 第三方工具
  - MAT：基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗
  - JProfiler：商业软件，需要付费。功能强大。
  - Arthas：Alibaba开源的Java诊断工具。
  - Btrace：Java运行时追踪工具。可以在不停机的情况下，跟踪指定的方法调用、构造函数调用和系统内存等信息。

## jConsole

### 基本概述

- 从JDK5开始，在JDK自带的java监控和管理控制台。
- 用于对JVM中内存、线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监控工具。

## Visual VM

### 基本概述

- 是一个功能强大的多合一故障诊断和性能监控的可视化工具。
- 集成了多个JDK命令行工具，使用Visual VM可用于显示虚拟机进程及进程的配置和环境信息（jps，jinfo），监视应用程序的CPU、GC、堆、方法区和线程的信息（jstat、jstack）等，甚至代替JConsole。
- Visual VM也可以作为独立的软件安装。

### 插件的安装

idea插件的安装、visualvm插件的安装

### 连接方式

#### 本地连接

监控本地Java进程的CPU、类、线程等

#### 远程连接

1. 确定远程服务器的ip地址
2. 添加JMX（通过JMX技术具体监控远端服务器哪个进程）
3. 修改bin/catalina.sh文件，连接远程的tocat
4. 在../conf添加jmxremote.access和jmxremote.password文件
5. 将服务器地址改为公网ip地址
6. 设置阿里云安全策略和防火墙cel
7. 启动tomcat，查看tomcat启动日志和端口监控
8. JMX中输入端口号、用户名、密码登录

### 主要功能

1. 生成/读取堆内存快照
2. 查看JVM参数和系统属性
3. 查看运行中的虚拟机进程
4. 生成/读取线程快照
5. 程序资源的实时监控
6. 其他功能（JMX代理连接、远程环境监控、CPU分析和内存分析）

## eclipse MAT

### 基本概述

MAT工具是一个款功能强大的Java堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。

### 获取堆dump文件

#### dump文件内容

MAT可以分析heap dump文件。在进行内存分析时，只要获得了反应当前设备映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息。

一般来说，这些内存信息包含：

- 所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其它对象的引用值。
- 所有的类信息，包括classloader、类名称、父类、静态变量等
- GCRoot到所有的这些对象的引用路径
- 线程信息，包括线程的调用栈及此线程的线程局部变量（TLS）

#### 两点说明

1. 不是一个万能工具，并不能处理所有类型的堆存储文件，支持主流的厂家和格式。
2. 最吸引人的还是能够快速为开发人员生成内存泄漏报表，方便定位问题和分析问题。

#### 获取dump文件

1. jmap工具生成，可以生成任意一个java进程的dump文件
2. 通过配置参数生成
   - 选项`-XX:+HeapDumpOnOutOfMemoryError`或`-XX:+HeapDumpBeforeFullGC`
   - 选项`-XX:HeapDumpPath`表示当程序出现OOM时，将会在响应的目录下生成一份dump文件，若不指定该参数则在当前目录下生成dump文件
   - 考虑到生成环境中几乎不可能在线对其进行分析，大都是采用离线分析，因此使用jmap+MAT工具是最常见的组合。
3. 使用VisualVM可以导出dump文件
4. 使用MAT既可以打开衣蛾已有的堆快照，也可以通过MAT直接从活动Java程序中导出堆快照。

### 分析堆dump文件

#### histogram

MAT的直方图和jmap的-histo子命令一样，都能够展示各个类的实例数目以及这些实例的shallow heap总和。但是，MAT的直方图还能够计算Retained heap，并支持基于实例数目或Retained heap的排序方式（默认为Shallow heap）。

此外，MAT还可以将直方图中的类按照超类、类加载器或者包名分组。

当选中某个类时，MAT界面左上角的Inspector窗口将展示该类的Class实例的相关信息，如类加载器等。

展示了各个类的实例数目以及这些实例数目以及这些实例的Shallow heap或Retained heap的总和。

#### thread overview

- 查看系统中的Java线程
- 查看局部变量的信息

#### 获得对象相互引用的关系

- with outgoing references
- with incoming references

#### 浅堆与深堆

##### shallow heap

浅堆是指一个对象所消耗的内存。在32位系统中，一个对象引用会占用4个字节，一个int类型会占据4个字节，long类型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会向8个字节进行对齐。

以String为例：2个int值共占8个字节，对象引用占用4个字节，对象头8字节，合计20字节，向8字节对齐，所以共占24字节。（JDK7）

这24字节为String对象的浅堆大小。它与String的value实际取值无关，无论字符串长度如何，浅堆大小始终是24字节。

##### retained heap

保留集（Retained Set）：对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括对象A本身），即对象A的保留集可以被认为只能通过对象A被直接或间接访问到的所有对象的集合。通俗的说，就是指仅被对象A所持有的对象的集合。

深堆是指对象的保留集中所有的对象的浅堆大小之和。

注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。

##### 补充：对象实际大小

另外一个常用的概念是对象的实际大小。这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，这个在日常开发中更为直观和被人接受，但实际上，这个概念和垃圾回收无关。

下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A和D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。

![深堆和浅堆](https://github.com/jackhusky/jvm/blob/main/docs/images/深堆和浅堆.png)

 

#### 支配树







